{
  "id": "typescript-strict-mode-patterns",
  "title": "TypeScript Strict Mode Best Practices",
  "description": "Comprehensive guide to using TypeScript in strict mode for better type safety, error prevention, and improved developer experience in production applications.",
  "technology": "typescript",
  "category": "code-quality",
  "priority": "critical",
  "status": "implemented",
  "problem": "Without strict TypeScript configuration, applications can have runtime errors that could be caught at compile time, poor IntelliSense experience, inconsistent null/undefined handling, and implicit any types that reduce type safety benefits.",
  "solution": "Enable strict mode in TypeScript configuration and follow strict typing patterns including proper null/undefined handling, explicit return types, strict function types, and comprehensive type definitions for all external APIs and data structures.",
  "rationale": "Strict mode catches more errors at compile time, provides better IDE support, improves code maintainability, and reduces runtime errors. The upfront investment in proper typing pays dividends in debugging time saved and confidence in refactoring.",
  "code_examples": [
    {
      "title": "Strict TypeScript Configuration",
      "description": "Optimal tsconfig.json for strict mode in a Next.js project",
      "language": "json",
      "filename": "tsconfig.json",
      "code": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"ES6\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    },\n    // Strict mode options\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"noImplicitOverride\": true,\n    \"noPropertyAccessFromIndexSignature\": true,\n    \"noUncheckedSideEffectImports\": true\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}",\n      \"highlight_lines\": [6, 25, 26, 27, 28, 29, 30, 31, 32, 33]\n    },\n    {\n      \"title\": \"Strict Type Definitions for API Data\",\n      \"description\": \"Comprehensive type definitions with validation\",\n      \"language\": \"typescript\",\n      \"filename\": \"types/api.ts\",\n      \"code\": \"import { z } from 'zod';\\n\\n// Zod schema for runtime validation\\nconst ProductSchema = z.object({\\n  id: z.string().min(1),\\n  name: z.string().min(1),\\n  description: z.string(),\\n  price: z.number().positive(),\\n  category_id: z.string().min(1),\\n  image_url: z.string().url().optional(),\\n  in_stock: z.boolean(),\\n  created_at: z.string().datetime(),\\n  updated_at: z.string().datetime(),\\n  metadata: z.record(z.unknown()).optional()\\n});\\n\\n// TypeScript type from Zod schema\\nexport type Product = z.infer<typeof ProductSchema>;\\n\\n// API Response wrapper with strict typing\\nexport interface ApiResponse<T> {\\n  readonly data: T;\\n  readonly success: true;\\n  readonly message?: string;\\n}\\n\\nexport interface ApiError {\\n  readonly success: false;\\n  readonly error: {\\n    readonly code: string;\\n    readonly message: string;\\n    readonly details?: Record<string, unknown>;\\n  };\\n}\\n\\nexport type ApiResult<T> = ApiResponse<T> | ApiError;\\n\\n// Type guard functions\\nexport function isApiSuccess<T>(result: ApiResult<T>): result is ApiResponse<T> {\\n  return result.success === true;\\n}\\n\\nexport function isApiError<T>(result: ApiResult<T>): result is ApiError {\\n  return result.success === false;\\n}\\n\\n// Validation function\\nexport function validateProduct(data: unknown): Product {\\n  return ProductSchema.parse(data);\\n}\\n\\n// Safe API call with proper error handling\\nexport async function fetchProducts(): Promise<ApiResult<Product[]>> {\\n  try {\\n    const response = await fetch('/api/products');\\n    \\n    if (!response.ok) {\\n      return {\\n        success: false,\\n        error: {\\n          code: 'HTTP_ERROR',\\n          message: `HTTP ${response.status}: ${response.statusText}`\\n        }\\n      };\\n    }\\n    \\n    const rawData = await response.json();\\n    \\n    // Validate data shape\\n    if (!Array.isArray(rawData)) {\\n      return {\\n        success: false,\\n        error: {\\n          code: 'INVALID_DATA',\\n          message: 'Expected array of products'\\n        }\\n      };\\n    }\\n    \\n    // Validate each product\\n    const products = rawData.map((item, index) => {\\n      try {\\n        return validateProduct(item);\\n      } catch (error) {\\n        throw new Error(`Invalid product at index ${index}: ${error}`);\\n      }\\n    });\\n    \\n    return {\\n      success: true,\\n      data: products\\n    };\\n  } catch (error) {\\n    return {\\n      success: false,\\n      error: {\\n        code: 'FETCH_ERROR',\\n        message: error instanceof Error ? error.message : 'Unknown error'\\n      }\\n    };\\n  }\\n}\",\n      \"highlight_lines\": [21, 22, 23, 26, 27, 28, 29, 30, 31, 32, 37, 41, 46]\n    },\n    {\n      \"title\": \"Strict Event Handler Patterns\",\n      \"description\": \"Type-safe event handlers with proper null checking\",\n      \"language\": \"typescript\",\n      \"filename\": \"components/product-form.tsx\",\n      \"code\": \"'use client';\\n\\nimport { useState, useCallback } from 'react';\\nimport { Product } from '@/types/api';\\n\\ninterface ProductFormProps {\\n  readonly product?: Product;\\n  readonly onSubmit: (product: Omit<Product, 'id' | 'created_at' | 'updated_at'>) => Promise<void>;\\n  readonly onCancel: () => void;\\n}\\n\\ninterface FormData {\\n  readonly name: string;\\n  readonly description: string;\\n  readonly price: string; // Keep as string for form input\\n  readonly category_id: string;\\n  readonly image_url: string;\\n  readonly in_stock: boolean;\\n}\\n\\ninterface FormErrors {\\n  readonly [K in keyof FormData]?: string;\\n}\\n\\nexport function ProductForm({ product, onSubmit, onCancel }: ProductFormProps) {\\n  const [formData, setFormData] = useState<FormData>({\\n    name: product?.name ?? '',\\n    description: product?.description ?? '',\\n    price: product?.price.toString() ?? '',\\n    category_id: product?.category_id ?? '',\\n    image_url: product?.image_url ?? '',\\n    in_stock: product?.in_stock ?? true\\n  });\\n  \\n  const [errors, setErrors] = useState<FormErrors>({});\\n  const [isSubmitting, setIsSubmitting] = useState(false);\\n  \\n  const validateForm = useCallback((data: FormData): FormErrors => {\\n    const newErrors: FormErrors = {};\\n    \\n    if (!data.name.trim()) {\\n      newErrors.name = 'Product name is required';\\n    }\\n    \\n    if (!data.description.trim()) {\\n      newErrors.description = 'Description is required';\\n    }\\n    \\n    const price = parseFloat(data.price);\\n    if (isNaN(price) || price <= 0) {\\n      newErrors.price = 'Price must be a positive number';\\n    }\\n    \\n    if (!data.category_id) {\\n      newErrors.category_id = 'Category is required';\\n    }\\n    \\n    if (data.image_url && !isValidUrl(data.image_url)) {\\n      newErrors.image_url = 'Image URL must be a valid URL';\\n    }\\n    \\n    return newErrors;\\n  }, []);\\n  \\n  const handleInputChange = useCallback((\\n    field: keyof FormData\\n  ) => (\\n    event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>\\n  ) => {\\n    const value = event.target.type === 'checkbox' \\n      ? (event.target as HTMLInputElement).checked\\n      : event.target.value;\\n    \\n    setFormData(prev => ({\\n      ...prev,\\n      [field]: value\\n    }));\\n    \\n    // Clear error when user starts typing\\n    if (errors[field]) {\\n      setErrors(prev => {\\n        const newErrors = { ...prev };\\n        delete newErrors[field];\\n        return newErrors;\\n      });\\n    }\\n  }, [errors]);\\n  \\n  const handleSubmit = useCallback(async (event: React.FormEvent<HTMLFormElement>) => {\\n    event.preventDefault();\\n    \\n    const formErrors = validateForm(formData);\\n    if (Object.keys(formErrors).length > 0) {\\n      setErrors(formErrors);\\n      return;\\n    }\\n    \\n    setIsSubmitting(true);\\n    \\n    try {\\n      await onSubmit({\\n        name: formData.name.trim(),\\n        description: formData.description.trim(),\\n        price: parseFloat(formData.price),\\n        category_id: formData.category_id,\\n        image_url: formData.image_url || undefined,\\n        in_stock: formData.in_stock\\n      });\\n    } catch (error) {\\n      console.error('Form submission error:', error);\\n    } finally {\\n      setIsSubmitting(false);\\n    }\\n  }, [formData, validateForm, onSubmit]);\\n  \\n  return (\\n    <form onSubmit={handleSubmit} className=\\\"space-y-4\\\">\\n      {/* Form fields with proper typing */}\\n    </form>\\n  );\\n}\\n\\nfunction isValidUrl(string: string): boolean {\\n  try {\\n    new URL(string);\\n    return true;\\n  } catch {\\n    return false;\\n  }\\n}\",\n      \"highlight_lines\": [6, 7, 8, 11, 20, 21, 26, 27, 28, 63, 64, 65, 82, 83]\n    }\n  ],\n  \"resources\": [\n    {\n      \"title\": \"TypeScript Handbook - Strict Mode\",\n      \"url\": \"https://www.typescriptlang.org/tsconfig#strict\",\n      \"type\": \"documentation\",\n      \"description\": \"Official documentation for TypeScript strict mode options\",\n      \"is_official\": true\n    },\n    {\n      \"title\": \"TypeScript Best Practices\",\n      \"url\": \"https://typescript-eslint.io/rules/\",\n      \"type\": \"documentation\",\n      \"description\": \"ESLint rules for TypeScript best practices\"\n    },\n    {\n      \"title\": \"Zod Documentation\",\n      \"url\": \"https://zod.dev/\",\n      \"type\": \"documentation\",\n      \"description\": \"Schema validation library for TypeScript\",\n      \"is_official\": true\n    }\n  ],\n  \"version_info\": {\n    \"technology_version\": \"5.0+\",\n    \"compatibility_notes\": \"These patterns work best with TypeScript 5.0+ and modern bundlers that support newer TypeScript features.\",\n    \"breaking_changes\": [\n      \"Strict mode may reveal existing type errors in legacy code\",\n      \"exactOptionalPropertyTypes requires careful handling of optional properties\"\n    ]\n  },\n  \"tags\": [\n    \"strict-mode\",\n    \"type-safety\",\n    \"error-prevention\",\n    \"code-quality\",\n    \"runtime-validation\",\n    \"zod\",\n    \"api-types\"\n  ],\n  \"related_practices\": [\n    \"nextjs-app-router-optimization\",\n    \"react-19-concurrent-patterns\"\n  ],\n  \"created_at\": \"2025-06-28T12:00:00Z\",\n  \"updated_at\": \"2025-06-28T12:00:00Z\",\n  \"author\": \"Development Team\",\n  \"reviewed_by\": [\"TypeScript Expert\", \"Senior Developer\"],\n  \"implementation_complexity\": \"high\",\n  \"estimated_time\": \"4-8 hours for existing project migration\",\n  \"prerequisites\": [\n    \"TypeScript 5.0+\",\n    \"Understanding of TypeScript basics\",\n    \"Knowledge of runtime validation concepts\"\n  ],\n  \"validation_criteria\": [\n    \"No TypeScript compilation errors with strict mode enabled\",\n    \"All API responses properly typed and validated\",\n    \"Event handlers have proper type safety\",\n    \"No implicit any types in codebase\",\n    \"Runtime validation covers all external data\"\n  ],\n  \"test_examples\": [\n    {\n      \"title\": \"Type Safety Tests\",\n      \"description\": \"Test that ensures type safety is maintained\",\n      \"language\": \"typescript\",\n      \"filename\": \"__tests__/type-safety.test.ts\",\n      \"code\": \"import { validateProduct, fetchProducts, isApiSuccess } from '../types/api';\\n\\ndescribe('Type Safety', () => {\\n  test('validateProduct rejects invalid data', () => {\\n    const invalidData = {\\n      id: '',\\n      name: '',\\n      price: -10\\n    };\\n    \\n    expect(() => validateProduct(invalidData)).toThrow();\\n  });\\n  \\n  test('validateProduct accepts valid data', () => {\\n    const validData = {\\n      id: 'prod-123',\\n      name: 'Test Product',\\n      description: 'A test product',\\n      price: 29.99,\\n      category_id: 'cat-123',\\n      in_stock: true,\\n      created_at: new Date().toISOString(),\\n      updated_at: new Date().toISOString()\\n    };\\n    \\n    expect(() => validateProduct(validData)).not.toThrow();\\n  });\\n  \\n  test('API result type guards work correctly', async () => {\\n    const result = await fetchProducts();\\n    \\n    if (isApiSuccess(result)) {\\n      // TypeScript knows result.data is Product[]\\n      expect(Array.isArray(result.data)).toBe(true);\\n    } else {\\n      // TypeScript knows result.error exists\\n      expect(typeof result.error.code).toBe('string');\\n    }\\n  });\\n});\"\n    }\n  ]\n}